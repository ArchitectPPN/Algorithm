问题1: size_t initlen = (init == NULL) ? 0 : strlen(init); 这段代码中, 假设init为null, 那么initlen就是0, 但是0是一个int类型, initlen是一个size_t类型, 不会出错嘛?

```c
size_t initlen = (init == NULL) ? 0 : strlen(init);
```

在这段 C/C++ 代码中，initlen 被定义为 size_t 类型，而条件表达式中的 0 是一个整数字面量，在默认情况下它的类型是 int。不过，在大多数现代编译器中，将较小的整数类型赋值给较大的整数类型变量时，并不会导致编译错误。

这里的关键点在于，size_t 通常是一个无符号整数类型，用于表示大小和索引等非负数值。当将 0 赋值给 size_t 类型的变量时，它会被隐式转换为 size_t 类型。这种转换是安全的，并且在所有标准兼容的 C/C++ 编译器中都是被允许的。

总结一下：

1. 类型匹配：0 会被自动转换成 size_t 类型。
2. 安全性：这种转换是安全的，不会导致数据丢失或产生未定义行为。
3. 标准符合性：这种用法符合 C/C++ 标准。

因此，在这段代码中，即使 init 为 NULL 导致 initlen 被赋值为 0，也不会出现类型不匹配的问题。

问题2: 

size_t 是 C 和 C++ 语言中定义的一种无符号整数类型，它主要用于表示对象的大小或者数组的索引长度。size_t 的定义位于 <cstddef> 头文件中，这是 C++ 标准库的一部分，对应于 C 语言中的 <stddef.h> 头文件。
```c
// 在 stddef.h 或 cstddef 中
typedef unsigned long size_t;
```
size_t 的主要用途包括：
1. 计算和表示对象的大小。
2. 作为数组索引。
3. 表示非负整数值，特别是与内存管理相关的操作。

size_t 的大小是平台相关的，这意味着它可以根据编译器和操作系统的变化而变化。
它的大小通常被设计成足够大，以确保能够表示系统上最大可能的对象大小。
例如，在 32 位系统上，size_t 可能是 32 位的无符号整数；而在 64 位系统上，它可能是 64 位的无符号整数。