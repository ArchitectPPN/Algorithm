### 压缩列表

采用连续内存存储

- 优势：
    - 内存效率高：
        - 原因：压缩列表使用紧凑的方式存储数据，通过使用可变长度编码（Varlen
          Encoding）来压缩不同长度的元素，避免了额外的元数据开销。这种设计非常适合存储小量数据的场景，比如小列表或短字符串。
        - 优势表现：这种压缩方式大幅减少了内存占用，尤其适用于存储大量的小对象。
  
    - 适合小规模数据存储：
        - 原因：在列表和哈希数据结构中，压缩列表适用于存储少量元素。Redis 在元素较少的情况下会默认使用压缩列表，以节省内存。
        - 优势表现：对于小列表和小哈希表的场景，压缩列表能够高效存储和读取，不需要引入复杂的数据结构。

    - 顺序访问高效：
        - 原因：压缩列表的元素是连续存储在内存中的，顺序遍历时不需要频繁跳转内存地址。
        - 优势表现：顺序访问时，数据在内存中是紧凑连续的，读取操作较为高效，尤其是在内存访问局部性好的情况下。

- 劣势：
    - 压缩列表的元素不能超过2^16-1个

    - 随机访问性能差：
        - 原因：由于压缩列表使用紧凑存储，所有元素是紧密排列在一起的。为了找到某个元素，Redis 需要从头开始线性遍历整个列表，导致随机访问的时间复杂度为
          O(n)。
        - 劣势表现：对于较长的列表或哈希表，随机访问操作（如通过索引查找元素）性能较差。

    - 更新操作效率低：
        - 原因：压缩列表中的每个元素可能会占用不同的字节长度，插入或删除元素时，可能会导致后续元素的移动或重新分配空间。如果插入的元素长度变化较大，会造成较大的内存移动开销。
        - 劣势表现：更新操作（例如插入、删除、修改）可能会引发大规模的内存重排，降低了性能，尤其在列表很长时。

    - 不适合大数据量存储：
        - 原因：压缩列表是为节省内存而设计的，但随着数据量的增加，遍历和更新的时间开销也会成倍增加。同时，大量数据会使压缩列表的可变长度编码机制变得复杂，操作效率大幅降低。
        - 劣势表现：当数据量大时，压缩列表的性能劣化显著，Redis 会根据配置或自动切换到更适合大规模数据存储的结构（如
          quicklist、hashtable）。

    - 内存碎片问题：
        - 原因：压缩列表在插入和删除操作中频繁改变长度，可能会导致内存重排，造成内存碎片化。这种内存碎片会降低内存利用率，影响整体性能。
        - 劣势表现：频繁更新操作可能会导致内存管理压力增大，特别是在多次插入和删除操作之后，可能引发内存碎片问题。

压缩列表存储方式:
从下面这个存储结构上就可以看到, 压缩列表啥也不存的情况下, 已经占用了11个字节.
```
|zlbytes|zltail|zllen|entry1|entry2|......|zlend|
```

- zlbytes:压缩列表的长度，以字节为单位,占4个字节,因此最大长度为2^32-1
- zltail:相当于压缩列表起始地址的偏移量,占4个字节
- zllen:压缩列表中实际存储的元素个数,占2个字节,因此最大值为2^16-1.zllen无法存储元素个数超过2^16-1个元素,必须遍历整个压缩列表才能知道元素个数
- entry:压缩列表的元素,可以是字节数组或者整数,长度不限.
- zlend:压缩列表的结尾,占1个字节,恒为0xFF.0xff（或二进制11111111）经常被用作结尾标记,尤其是在数据传输或者文件格式中,
  因为它是一个很容易识别的全1比特模式

压缩列表元素的存储方式:

```
|previous_entry_length|encoding|content|
```

- previous_entry_length:表示前一个元素的字节长度,占1个或者5个字节,当前一个字节长度小于254时,使用1字节表示,大于254时,使用5个字节表示.
  使用5字节表示时,第一个字节固定为0xFE,后面4个字节表示前一个元素的字节长度
- encoding:表示当前元素的编码方式,为了节约内存,encoding字段同样长度可变
- content:元素的内容,长度由encoding字段决定

