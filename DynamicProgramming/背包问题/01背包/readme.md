### 百度给出的定义:
01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2至Wn，与之相对应的价值为P1,P2至Pn。
01背包是背包问题中最简单的问题。
01背包的约束条件是给定几种物品，每种物品有且只有一个，并且有权值和体积两个属性。
在01背包问题中，因为每种物品只有一个，对于每个物品只需要考虑选与不选两种情况。
如果不选择将其放入背包中，则不需要处理。
如果选择将其放入背包中，由于不清楚之前放入的物品占据了多大的空间，需要枚举将这个物品放入背包后可能占据背包空间的所有情况。

### 
题目：给定N个物品，其中第i个物品的体积是v[i]，价值是w[i]，现在有一个背包，容量是M，求解将哪些物品装入背包，在体积不超过M的情况下可使得所选物品价值最大。

### 推荐的视频
- [【自制】01背包问题算法动画讲解](https://www.bilibili.com/video/BV1pY4y1J7na/?spm_id_from=333.999.0.0&vd_source=fbff21b18c60ea6baf150910c8bd2c70)
  - 该视频讲解非常详细，清晰明了，推荐。

#### 模拟人工操作
，我们需要考虑第i个物品是否需要，如果需要背包剩余的容量是否能放下。所以我们需要一个二维数组dp，dp[i][j]表示前i个物品，背包容量为j的情况下，所选物品价值最大。

#### 动态转移方程
F[i][j],其中i表示选择前i个物品，j表示选择了i个物品后的体积。我们也可以认为从前i个物品中选出了总体积为j的物品放入背包，物品的最大价值总和。
- 不选择第i个物品，即F[i][j] = F[i-1][j]，因为不选择第i个物品，那么体积和价值都不会改变。
- 选择第i个物品，即F[i][j] = w[i] + F[i-1][j-v[i]]，因为可以选择第i个物品，那么体积和价值都会改变。

这个解法我们需要用二维数组来解决。

### 使用一维数组来解决
我们可以发现，使用二维数组来解决该问题时，从这个公式`F[i][j] = max(F[i-1][j], w[i] + F[i-1][j-v[i]])`中可以看出来，F[i]由F[i-1]转移过来，也就是说前面几行会变得无用。
`F[i][j]`的定义为选取i个物品，体积为j时的最大价值。我们只需要最终的状态F[N][M]。
- 我们只要定一个一维数组dp[j]，dp[j]表示选取前i个物品，体积为j时的最大价值。
- 一维数组时，枚举背包容量j必须从M开始，也就是必须倒序，从大到小开始。
  - 使用二维数组情况下，状态`F[i][j]`是由上一轮`F[i-1]`得来，两者在内存存储上相对独立存在的。
  - 使用一维数组情况下，`F[i]`和`F[i-1]`需要共用`F[j]`来存储。如果继续正序枚举，那么`F[i]`和`F[i-1]`会覆盖掉`F[j]`，导致`F[j]`丢失。

这里给出示例：
例子1:
假设有3件物品，背包的总体积为10。

| 物品    | 体积 | 价值 |
|-------|----|----|
| i = 1 | 4  | 5  |
| i = 2 | 5  | 6  |
| i = 3 | 6  | 7  |

如果 j 层循环是递增的：
```php
  for (int i = 1; i <= n; i++) {
      for (int j = v[i]; j <= m; j++) {
          f[j] = max(f[j], f[j - v[i]] + w[i]);
      }
  }
  /**
    当还未进入循环时(初始状态):
    f[0] = 0;  f[1] = 0;  f[2] = 0;  f[3] = 0;  f[4] = 0;  f[5] = 0;  f[6] = 0;  f[7] = 0;  f[8] = 0;  f[9] = 0; f[10] = 0;
    当进入循环 i == 1 时：
    f[4] = max(f[4], f[0] + 5); 即max(0, 5) = 5; 即f[4] = 5;
    f[5] = max(f[5], f[1] + 5); 即max(0, 5) = 5; 即f[5] = 5;
    f[6] = max(f[6], f[2] + 5); 即max(0, 5) = 5; 即f[6] = 5;
    f[7] = max(f[7], f[3] + 5); 即max(0, 5) = 5; 即f[7] = 5;
    重点来了！！！
    f[8] = max(f[8], f[4] + 5); 即max(0, 5 + 5) = 10; 即f[8] = 10; 这里就已经出错了
    因为此时处于 i == 1 这一层，即物品只有一件，不存在单件物品满足价值为10
    所以已经出错了。
    如果F[8] 这个位置不理解的话，可以想象二维数组下的情况为怎样的，二维数组的递推公式为：
    F[i][j] = max(F[i-1][j], w[i] + F[i-1][j - v[i]);
    代入到此处就是：
    F[1][8] = max(F[0][8], w[1] + F[0][4);
    二维数组中F[0]和F[1]天然不在同一行，一维数组中F[0]和F[1]处在同一行中，为了保持结果和二维数组一致，我们就需要倒序枚举计算。
    在F[8]的例子中，该逻辑已被破坏掉了，下面来仔细分析一下：
    F[8]的前提为每个物品仅能放入一次：
      现在我们选择第一个物品放入背包中，那么背包的容量还剩8-4=4，背包的价值发生变化0 -> 5。
      继续放入第二个物品，由于背包所剩容量为4，我们无法放入第二个物品，因此我们选择不放入第二个物品，此时背包的价值由5 -> 5。
    上面是我们理想的结果，但是现在的问题为：我们重新将容量为4的物品放入了背包中，也就是1号物品被选择了两次，显然和我们的要求不符。
    原因就是因为正序枚举导致的，二维数组时F[1][4]和F[0][4]为两行数据，一维数组F[1][4]和F[0][4]都为F[4]，那么这样就会导致计算F[i]时覆盖掉F[i-1]。
    当前i为1，F[8]放入1号物品后，1号物品就不能再被选择了，但是为了得到背包的最大价值，我们还需要加上背包剩余容量的价值。
    剩余容量的价值在二维数组时为F[0][4]，一维数组时为F[4]，我们是正序枚举的，在计算F[8]时，我们拿到的F[4]应该为F[0][4]，但是F[0][4]被F[1][4]覆盖掉了，所以最后的结果就是错误的。
    解决这个问题的方案就是倒序枚举背包容量。
 **/
```
如果 j 层循环是逆序的：
为什么倒序枚举背包容量能解决问题呢？
因为倒序枚举时，我们背包容量时从大到小变化的，这时候小背包的状态仍然停留在上一个状态。
这里还是拿二维数组的F[0][4]和F[1][4]和一维数组的F[4]来说明，由于倒序的原因，只有当前倒序循环的j(枚举的背包容量)为4时，F[1][4]才会代替F[0][4]，从而保证正确。
```php
    for (int i = 1; i <= n; i++) {
      for (int j = m; j >= v[i]; j--) {
          f[j] = max(f[j], f[j - v[i]] + w[i]);
      }
  }
  /**
    当还未进入循环时:
      f[0] = 0;  f[1] = 0;  f[2] = 0;  f[3] = 0;  f[4] = 0;  f[5] = 0;  f[6] = 0;  f[7] = 0;  f[8] = 0;  f[9] = 0; f[10] = 0;
    当进入循环 i == 1 时：w[i] = 5; v[i] = 4;
      j = 10：f[10] = max(f[10], f[6] + 5); 即max(0, 5) = 5; 即f[10] = 5;
      j = 9 ：f[9] = max(f[9], f[5] + 5); 即max(0, 5) = 5; 即f[9] = 5;
      j = 8 ：f[8] = max(f[8], f[4] + 5); 即max(0, 5) = 5; 即f[8] = 5;
      j = 7 ：f[7] = max(f[7], f[3] + 5); 即max(0, 5) = 5; 即f[7] = 5;
      j = 6 ：f[6] = max(f[6], f[2] + 5); 即max(0, 5) = 5; 即f[6] = 5;
      j = 5 ：f[5] = max(f[5], f[1] + 5); 即max(0, 5) = 5; 即f[5] = 5;
      j = 4 ：f[6] = max(f[4], f[0] + 5); 即max(0, 5) = 5; 即f[4] = 5;
    当进入循环 i == 2 时：w[i] = 6; v[i] = 5; 
      j = 10：f[10] = max(f[10], f[5] + 6); 即max(5, 11) = 11; 即f[10] = 11;
      j = 9 ：f[9] = max(f[9], f[4] + 6); 即max(5, 11) = 5; 即f[9] = 11;
      j = 8 ：f[8] = max(f[8], f[3] + 6); 即max(5, 6) = 6; 即f[8] = 6;
      j = 7 ：f[7] = max(f[7], f[2] + 6); 即max(5, 6) = 6; 即f[7] = 6;
      j = 6 ：f[6] = max(f[6], f[1] + 6); 即max(5, 6) = 6; 即f[6] = 6;
      j = 5 ：f[4] = max(f[5], f[0] + 6); 即max(5, 6) = 6; 即f[5] = 6;
    当进入循环 i == 3 时: w[i] = 7; v[i] = 6; 
      j = 10：f[10] = max(f[10], f[4] + 7); 即max(11, 12) = 12; 即f[10] = 12;
      j = 9 ：f[9] = max(f[9], f[3] + 6); 即max(11, 6) = 11; 即f[9] = 11;
      j = 8 ：f[8] = max(f[8], f[2] + 6); 即max(6, 6) = 6; 即f[8] = 6;
      j = 7 ：f[7] = max(f[7], f[1] + 6); 即max(6, 6) = 6; 即f[7] = 6;
      j = 6 ：f[6] = max(f[6], f[0] + 6); 即max(6, 6) = 6; 即f[6] = 6;
    
    状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] 。
 */
```


